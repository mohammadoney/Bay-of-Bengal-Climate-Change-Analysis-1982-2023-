# 1st Analysis: To identify temporal change and measure it 
!pip install rasterio rioxarray

import numpy as np
import xarray as xr
import pandas as pd
import pymannkendall as mk
import rioxarray  # activates the rio accessor/backend [web:90][web:99]

tif_path = "/content/drive/MyDrive/earthengine/Annual_Median_SST_BoB_1982_2024.tif"

# Load as DataArray: dims ('band','y','x')
da = rioxarray.open_rasterio(tif_path)  # or xr.open_dataarray(..., engine="rasterio") after this [web:94][web:91]

# Time coord: 1982–2024
n_time = da.sizes["band"]
start_year = 1982
time = pd.date_range(f"{start_year}-01-01", periods=n_time, freq="AS")

da = da.assign_coords(band=time).rename(band="time")

# Basin-mean annual SST
basin_ts_annual = da.mean(dim=("y", "x"), skipna=True)

y = basin_ts_annual.values
mask = np.isfinite(y)
y_clean = y[mask]

result = mk.original_test(y_clean)

print("Years:", time[mask][0].year, "to", time[mask][-1].year)
print("Trend:", result.trend)
print("h (significant?):", result.h)
print("p-value:", result.p)
print("Tau:", result.Tau)
print("Z:", result.z)
print("Sen's slope (SST units/year):", result.slope)
print("Intercept:", result.intercept)

# 2nd Analysis: To identify saptial change
!pip install rasterio pymannkendall matplotlib numpy
import numpy as np
import rasterio
from rasterio.plot import show
import pymannkendall as mk
import matplotlib.pyplot as plt

tif_path = "/content/drive/MyDrive/earthengine/Annual_Median_SST_BoB_1982_2024.tif"

# ---- read the GeoTIFF ----
with rasterio.open(tif_path) as src:
    data = src.read()           # shape: (T, Y, X)
    meta = src.meta.copy()

# assume first axis is time (one band per year)
n_t, n_y, n_x = data.shape

# pre‑allocate Sen’s slope and MK Z
sen_slope = np.full((n_y, n_x), np.nan, dtype="float32")
mk_z      = np.full((n_y, n_x), np.nan, dtype="float32")

# time step (years) – here 1 year between images
dt = 1.0

for i in range(n_y):
    for j in range(n_x):
        ts = data[:, i, j]

        # mask pixels that are all nan
        if np.all(np.isnan(ts)):
            continue

        # drop nans
        mask = ~np.isnan(ts)
        y = ts[mask]

        if y.size < 5:   # too short to test
            continue

        # Mann–Kendall + Sen’s slope
        res = mk.original_test(y)   # trend, h, p, z, Tau, s, var_s, slope, intercept [web:7][web:9]
        sen_slope[i, j] = res.slope / dt
        mk_z[i, j]      = res.z

# ---- plot like your figure ----
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Sen's slope map
im1 = ax1.imshow(
    sen_slope,
    cmap="RdBu_r",
    vmin=-0.03, vmax=0.03,   # adjust to your range
    origin="upper"
)
ax1.set_title("SSD Trend Magnitude (Sen’s Slope per Year)")
ax1.axis("off")
cbar1 = fig.colorbar(im1, ax=ax1, fraction=0.046, pad=0.04)
cbar1.set_label("Sen’s slope (per year)")

# MK Z-score map
im2 = ax2.imshow(
    mk_z,
    cmap="RdBu_r",
    vmin=-4, vmax=4,
    origin="upper"
)
ax2.set_title("SSD Trend Significance (MK Z-Score)")
ax2.axis("off")
cbar2 = fig.colorbar(im2, ax=ax2, fraction=0.046, pad=0.04)
cbar2.set_label("MK Z-score")

plt.tight_layout()
plt.show()


